# Лабораторная работа 1

## Плохие и хорошие практики написания Dockerfile

### Плохие практики в `dockerfile.bad`

1. **Использование "жирного" образа**
   - **Проблема**: Используется базовый образ `python`, который часто "тяжелее".
   - **Почему это плохо**: Это приводит к увеличению размера образа.
   - **Исправлено в good.Dockerfile**: Используется легковесный образ `python:3.12-slim`, что уменьшает размер.

2. **Копирование всех файлов проекта**
   - **Проблема**: Команда `COPY .. /shop_api` копирует все файлы, включая ненужные и потенциально опасные, такие как `.env`.
   - **Почему это плохо**: Это увеличивает размер образа и может привести к утечке конфиденциальных данных.
   - **Исправлено в good.Dockerfile**: Копируются только необходимые файлы, такие как `pyproject.toml`, `poetry.lock`, и директория `shop_api`.

3. **Разделение команд в отдельных слоях**
   - **Проблема**: Каждая команда `RUN` создает новый слой, что увеличивает количество слоев и размер образа.
   - **Почему это плохо**: Чем больше слоев, тем больше итоговый размер образа и сложнее его поддерживать.
   - **Исправлено в good.Dockerfile**: Все команды объединены в одну строку с использованием `&&`, что уменьшает количество слоев.

4. **Запуск приложения под root-пользователем**
   - **Проблема**: По умолчанию контейнеры запускаются под пользователем root.
   - **Почему это плохо**: Это создает потенциальные уязвимости безопасности, так как приложение имеет слишком высокие привилегии.
   - **Исправлено в good.Dockerfile**: Добавляется некорневой пользователь с помощью `RUN useradd -m appuser` и переключение на него `USER appuser`.

5. **Не указана фиксированная версия базового образа**
   - **Проблема**: Использование образа без указания конкретной версии, например `python:3`, может привести к непредсказуемым результатам при обновлении образа.
   - **Почему это плохо**: Это делает сборку нестабильной и неповторяемой.
   - **Исправлено в good.Dockerfile**: Указывается конкретная версия образа `python:3.12-slim`.

6. **Отсутствие файла `.dockerignore`**
   - **Проблема**: Все файлы из контекста сборки копируются в Docker-демон, включая ненужные.
   - **Почему это плохо**: Это увеличивает время сборки и размер образа.
   - **Исправлено в good.Dockerfile**: Добавлен файл `.dockerignore`, который исключает ненужные файлы из контекста сборки.

7. **Использование `apt-get` без очистки кеша**
   - **Проблема**: После установки пакетов остаются временные файлы и кеш.
   - **Почему это плохо**: Увеличивает размер образа без необходимости.
   - **Исправлено в good.Dockerfile**: Добавлена команда очистки `rm -rf /var/lib/apt/lists/*`.

### Хорошие практики в `dockerfile.good`

- **Использование легковесного образа**: `python:3.12-slim` обеспечивает меньший размер образа и более быструю загрузку.
- **Копирование только нужных файлов**: Минимизирует размер образа и улучшает безопасность, не копируя лишние или потенциально опасные файлы.
- **Оптимизация слоев**: Объединение команд в одну строку уменьшает количество слоев, что приводит к более эффективному использованию ресурсов.
- **Запуск приложения от некорневого пользователя**: Повышает безопасность, ограничивая привилегии приложения внутри контейнера.
- **Указание конкретных версий зависимостей**: Гарантирует предсказуемость и стабильность сборки.
- **Использование файла `.dockerignore`**: Исключает ненужные файлы из контекста сборки, ускоряя процесс и уменьшая размер образа.
- **Очистка после установки пакетов**: Удаляет временные файлы и кеши, что снижает размер финального образа.
- **Многоступенчатая сборка (multi-stage build)**: Позволяет использовать промежуточные образы для сборки и включать в финальный образ только необходимые артефакты.

## Плохие практики контейнеризации

1. **Хранение данных внутри контейнера**
   - Использование контейнера для хранения данных через volume без внешнего резервного копирования может привести к потере данных при удалении контейнера.

2. **Использование контейнеров для монолитных приложений**
   - Контейнеры лучше всего подходят для микросервисной архитектуры, а запуск монолитных приложений может свести на нет все преимущества контейнеризации.

3. **Развертывание баз данных в контейнерах**
   - Хотя контейнеры могут использоваться для тестирования баз данных, запуск полноценных баз данных в контейнерах в продакшене — плохая практика. Контейнеры являются еще одной дополнительной абстракцией над железом, поэтому их лучше не использовать под такие ресурсоемкие сервисы как БД с большим количеством операций чтения/записи на диск.

4. **Неограниченное использование ресурсов**
   - **Проблема**: Запуск контейнеров без указания лимитов по CPU и памяти.
   - **Почему это плохо**: Может привести к истощению ресурсов хоста и деградации производительности.
   - **Решение**: Использовать параметры `--memory` и `--cpus` для ограничения потребления ресурсов контейнером.

5. **Хранение секретов в открытом виде**
   - **Проблема**: Передача конфиденциальных данных через переменные окружения или файлы в образе.
   - **Почему это плохо**: Угроза безопасности и утечки данных.
   - **Решение**: Использовать секреты Docker или сторонние сервисы для управления секретами.

6. **Отсутствие мониторинга и логирования**
   - **Проблема**: Невозможность отслеживать состояние контейнеров и быстро реагировать на проблемы.
   - **Почему это плохо**: Снижает надежность и управляемость системы.
   - **Решение**: Внедрить системы мониторинга и агрегирования логов, такие как Prometheus и ELK Stack.

7. **Запуск привилегированных контейнеров**
   - **Проблема**: Использование флага `--privileged` при запуске контейнеров без необходимости.
   - **Почему это плохо**: Увеличивает поверхность атаки и риски безопасности.
   - **Решение**: Избегать использования привилегированных контейнеров, если это не требуется для конкретных задач.

## Сборка и запуск

```bash
# Сборка образа с плохими практиками
docker rmi -f bad_docker && docker build -f dockerfile.bad -t bad_docker . && docker run -p 80:80 -it bad_docker

# Сборка образа с хорошими практиками
docker rmi -f good_docker && docker build -f dockerfile.good -t good_docker . && docker run -p 80:80 -it good_docker
```
